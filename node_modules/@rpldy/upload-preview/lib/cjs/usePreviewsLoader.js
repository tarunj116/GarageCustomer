"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _shared = require("@rpldy/shared");

var _sharedUi = require("@rpldy/shared-ui");

var _consts = require("./consts");

var _utils = require("./utils");

const getFilePreviewUrl = (file, options) => {
  let data = (0, _utils.getFileObjectUrlByType)(_consts.PREVIEW_TYPES.IMAGE, options.imageMimeTypes, options.maxPreviewImageSize || 0, file);

  if (!data) {
    data = (0, _utils.getFileObjectUrlByType)(_consts.PREVIEW_TYPES.VIDEO, options.videoMimeTypes, options.maxPreviewVideoSize || 0, file);
  }

  return data;
};

const loadPreviewData = (item, options, previewComponentProps) => {
  let data,
      props,
      isFallback = false;

  if (item.file) {
    const file = item.file;
    data = getFilePreviewUrl(item.file, options);

    if (!data) {
      data = (0, _utils.getFallbackUrlData)(options.fallbackUrl, file);
      isFallback = true;
    }
  } else {
    data = {
      url: item.url,
      name: item.url,
      type: _consts.PREVIEW_TYPES.IMAGE
    };
  }

  if (data) {
    const {
      url,
      type
    } = data;
    props = (0, _shared.isFunction)(previewComponentProps) ? previewComponentProps(item, url, type) : previewComponentProps;
  }

  return data && { ...data,
    id: item.id,
    isFallback,
    props
  };
};

const mergePreviewData = (prev, next) => {
  const newItems = []; //dedupe and merge new with existing

  next.forEach(n => {
    const existingIndex = prev.findIndex(p => p.id === n.id);

    if (~existingIndex) {
      prev.splice(existingIndex, 1, n);
    } else {
      newItems.push(n);
    }
  });
  return prev.concat(newItems);
};

var _default = props => {
  const [previews, setPreviews] = (0, _react.useState)([]);
  const previewOptions = (0, _utils.getWithMandatoryOptions)(props);
  const clearPreviews = (0, _react.useCallback)(() => {
    setPreviews([]);
  }, []);
  (0, _sharedUi.useBatchStartListener)(batch => {
    const items = previewOptions.loadFirstOnly ? batch.items.slice(0, 1) : batch.items;
    const previewsData = items.map(item => loadPreviewData(item, previewOptions, props.previewComponentProps)).filter(Boolean);
    setPreviews(props.rememberPreviousBatches ? mergePreviewData(previews, previewsData) : previewsData);
  });
  return {
    previews,
    clearPreviews
  };
};

exports.default = _default;
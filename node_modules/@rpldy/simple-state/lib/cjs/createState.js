"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isProxy", {
  enumerable: true,
  get: function () {
    return _utils.isProxy;
  }
});
exports.unwrap = exports.default = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("./consts");

var _utils = require("./utils");

const mergeWithSymbols = (0, _shared.getMerge)({
  withSymbols: true,
  predicate: key => key !== _consts.PROXY_SYM && key !== _consts.STATE_SYM
});

const getIsUpdateable = proxy => (0, _shared.isProduction)() ? true : proxy[_consts.STATE_SYM].isUpdateable;

const setIsUpdateable = (proxy, value) => {
  if (!(0, _shared.isProduction)()) {
    proxy[_consts.STATE_SYM].isUpdateable = value;
  }
};

const deepProxy = (obj, traps) => {
  let proxy;

  if ((0, _utils.isProxiable)(obj)) {
    if (!(0, _utils.isProxy)(obj)) {
      obj[_consts.PROXY_SYM] = true;
      proxy = new Proxy(obj, traps);
    }

    Object.keys(obj).forEach(key => {
      obj[key] = deepProxy(obj[key], traps);
    });
  }

  return proxy || obj;
};

const unwrapProxy = proxy => (0, _utils.isProxy)(proxy) ? (0, _shared.clone)(proxy, mergeWithSymbols) : proxy;
/**
 * deep proxies an object so it is only updateable through an update callback.
 * outside an updater, it is impossible to make changes
 *
 * This a very (very) basic and naive replacement for Immer
 *
 * It only proxies simple objects (not maps or sets) and arrays
 * It doesnt create new references and doesnt copy over anything
 *
 * Original object is changed!
 *
 * DOESNT support updating state (wrapped seperately) that is set as a child of another state
 * @param obj
 * @returns {{state, update, unwrap}}
 */


exports.unwrap = unwrapProxy;

var _default = obj => {
  const traps = {
    set: (obj, key, value) => {
      if (getIsUpdateable(proxy)) {
        obj[key] = deepProxy(value, traps);
      }

      return true;
    },
    get: (obj, key) => {
      return key === _consts.PROXY_SYM ? unwrapProxy(obj) : obj[key];
    },
    defineProperty: () => {
      throw new Error("Simple State doesnt support defining property");
    },
    setPrototypeOf: () => {
      throw new Error("Simple State doesnt support setting prototype");
    },
    deleteProperty: (obj, key) => {
      if (getIsUpdateable(proxy)) {
        delete obj[key];
      }

      return true;
    }
  };

  if (!(0, _shared.isProduction)() && !(0, _utils.isProxy)(obj)) {
    Object.defineProperty(obj, _consts.STATE_SYM, {
      value: {
        isUpdateable: false
      },
      configurable: true
    });
  }

  const proxy = !(0, _shared.isProduction)() ? deepProxy(obj, traps) : obj;
  return {
    state: proxy,
    update: fn => {
      if (!(0, _shared.isProduction)() && getIsUpdateable(proxy)) {
        throw new Error("Can't call update on State already being updated!");
      }

      try {
        setIsUpdateable(proxy, true);
        fn(proxy);
      } finally {
        setIsUpdateable(proxy, false);
      }

      return proxy;
    },
    unwrap: entry => entry ? //simply clone the provided object (if its a proxy)
    unwrapProxy(entry) : //unwrap entire proxy state
    (0, _utils.isProxy)(proxy) ? unwrapProxy(proxy) : proxy
  };
};

exports.default = _default;
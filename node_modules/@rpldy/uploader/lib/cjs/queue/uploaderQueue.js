"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _shared = require("@rpldy/shared");

var _simpleState = _interopRequireDefault(require("@rpldy/simple-state"));

var _consts = require("../consts");

var _processQueueNext = _interopRequireDefault(require("./processQueueNext"));

var abortMethods = _interopRequireWildcard(require("./abort"));

var _batchHelpers = require("./batchHelpers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {
  const {
    state,
    update
  } = (0, _simpleState.default)({
    itemQueue: [],
    currentBatch: null,
    batches: {},
    items: {},
    activeIds: [],
    aborts: {}
  });

  const getState = () => state;

  const updateState = updater => {
    update(updater);
  };

  const add = item => {
    if (state.items[item.id] && !item.recycled) {
      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);
    }

    if (item.recycled) {
      (0, _batchHelpers.detachRecycledFromPreviousBatch)(queueState, item);
    }

    updateState(state => {
      state.items[item.id] = item;
      state.itemQueue.push(item.id);
    });
  };

  const handleItemProgress = (item, completed, loaded) => {
    if (state.items[item.id]) {
      updateState(state => {
        const stateItem = state.items[item.id];
        stateItem.loaded = loaded;
        stateItem.completed = completed;
      }); //trigger item progress event for the outside

      trigger(_consts.UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);
    }
  };

  sender.on(_consts.SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);
  sender.on(_consts.SENDER_EVENTS.BATCH_PROGRESS, batch => {
    var _state$batches$batch$;

    const batchItems = (_state$batches$batch$ = state.batches[batch.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;

    if (batchItems) {
      const [completed, loaded] = batchItems.reduce((res, item) => {
        res[0] += item.completed;
        res[1] += item.loaded;
        return res;
      }, [0, 0]);
      updateState(state => {
        const stateBatch = state.batches[batch.id].batch; //average of completed percentage for batch items

        stateBatch.completed = completed / batchItems.length; //sum of loaded bytes for batch items

        stateBatch.loaded = loaded;
      });
      trigger(_consts.UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch.id].batch);
    }
  });
  const queueState = {
    uploaderId,
    getOptions: () => options,
    getCurrentActiveCount: () => state.activeIds.length,
    getState,
    updateState,
    trigger,
    runCancellable: (name, ...args) => {
      if (!(0, _shared.isFunction)(cancellable)) {
        //for flow :(
        throw new Error("cancellable is of wrong type");
      }

      return cancellable(name, ...args);
    },
    sender,
    handleItemProgress
  };

  if ((0, _shared.hasWindow)() && _shared.logger.isDebugOn()) {
    window[`__rpldy_${uploaderId}_queue_state`] = queueState;
  }

  return {
    updateState,
    getState: queueState.getState,
    runCancellable: queueState.runCancellable,
    uploadBatch: (batch, batchOptions) => {
      if (batchOptions) {
        updateState(state => {
          state.batches[batch.id].batchOptions = batchOptions;
        });
      }

      (0, _processQueueNext.default)(queueState);
    },
    addBatch: (batch, batchOptions) => {
      updateState(state => {
        state.batches[batch.id] = {
          batch,
          batchOptions,
          finishedCounter: 0
        };
      });
      batch.items.forEach(add);
      return (0, _batchHelpers.getBatchFromState)(state, batch.id);
    },
    abortItem: id => {
      return abortMethods.abortItem(queueState, id, _processQueueNext.default);
    },
    abortBatch: id => {
      abortMethods.abortBatch(queueState, id, _processQueueNext.default);
    },
    abortAll: () => {
      abortMethods.abortAll(queueState, _processQueueNext.default);
    },
    clearPendingBatches: () => {
      (0, _batchHelpers.removePendingBatches)(queueState);
    },
    uploadPendingBatches: uploadOptions => {
      (0, _batchHelpers.preparePendingForUpload)(queueState, uploadOptions);
      (0, _processQueueNext.default)(queueState);
    }
  };
};

var _default = createUploaderQueue;
exports.default = _default;
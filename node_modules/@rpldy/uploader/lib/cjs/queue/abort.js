"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abortBatch = exports.abortItem = exports.abortAll = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _batchHelpers = require("./batchHelpers");

var _processFinishedRequest = _interopRequireDefault(require("./processFinishedRequest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const abortNonUploadingItem = (queue, item, next) => {
  _shared.logger.debugLog(`uploader.queue: aborting ${item.state} item  - `, item); //manually finish request for item that hasnt reached the sender yet


  (0, _processFinishedRequest.default)(queue, [{
    id: item.id,
    info: {
      status: 0,
      state: _shared.FILE_STATES.ABORTED,
      response: "aborted"
    }
  }], next);
  return true;
};

const ITEM_STATE_ABORTS = {
  [_shared.FILE_STATES.UPLOADING]: (queue, item) => {
    _shared.logger.debugLog(`uploader.queue: aborting uploading item  - `, item);

    return queue.getState().aborts[item.id]();
  },
  [_shared.FILE_STATES.ADDED]: abortNonUploadingItem,
  [_shared.FILE_STATES.PENDING]: abortNonUploadingItem
};

const callAbortOnItem = (queue, id, next) => {
  const state = queue.getState(),
        item = state.items[id],
        itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]

  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]
  //$FlowIssue[prop-missing]
  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;
};

const abortAll = (queue, next) => {
  const items = queue.getState().items;
  Object.keys(items).forEach(id => callAbortOnItem(queue, id, next));
  queue.trigger(_consts.UPLOADER_EVENTS.ALL_ABORT);
};

exports.abortAll = abortAll;

const abortItem = (queue, id, next) => callAbortOnItem(queue, id, next);

exports.abortItem = abortItem;

const abortBatch = (queue, id, next) => {
  const state = queue.getState(),
        batchData = state.batches[id],
        batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;

  if (batch && !(0, _batchHelpers.getIsBatchFinalized)(batch)) {
    queue.updateState(state => {
      (0, _batchHelpers.getBatchFromState)(state, id).state = _shared.BATCH_STATES.ABORTED;
    });
    (0, _batchHelpers.triggerUploaderBatchEvent)(queue, id, _consts.UPLOADER_EVENTS.BATCH_ABORT);
    batch.items.forEach(bi => callAbortOnItem(queue, bi.id, next));
  }
};

exports.abortBatch = abortBatch;
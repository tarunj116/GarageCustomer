"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FILE_STATE_TO_EVENT_MAP = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _batchHelpers = require("./batchHelpers");

const FILE_STATE_TO_EVENT_MAP = {
  [_shared.FILE_STATES.PENDING]: null,
  [_shared.FILE_STATES.ADDED]: _consts.UPLOADER_EVENTS.ITEM_START,
  [_shared.FILE_STATES.FINISHED]: _consts.UPLOADER_EVENTS.ITEM_FINISH,
  [_shared.FILE_STATES.ERROR]: _consts.UPLOADER_EVENTS.ITEM_ERROR,
  [_shared.FILE_STATES.CANCELLED]: _consts.UPLOADER_EVENTS.ITEM_CANCEL,
  [_shared.FILE_STATES.ABORTED]: _consts.UPLOADER_EVENTS.ITEM_ABORT,
  [_shared.FILE_STATES.UPLOADING]: _consts.UPLOADER_EVENTS.ITEM_PROGRESS
};
exports.FILE_STATE_TO_EVENT_MAP = FILE_STATE_TO_EVENT_MAP;

const getIsFinalized = item => !!~_consts.ITEM_FINALIZE_STATES.indexOf(item.state);

const processFinishedRequest = (queue, finishedData, next) => {
  finishedData.forEach(itemData => {
    const state = queue.getState();
    const {
      id,
      info
    } = itemData;

    _shared.logger.debugLog("uploader.processor.queue: request finished for item - ", {
      id,
      info
    });

    if (state.items[id]) {
      queue.updateState(state => {
        const item = state.items[id];
        item.state = info.state;
        item.uploadResponse = info.response;
        item.uploadStatus = info.status;

        if (getIsFinalized(item)) {
          delete state.aborts[id];
        }
      }); //get most up-to-date item data

      const item = queue.getState().items[id];

      if (info.state === _shared.FILE_STATES.FINISHED && item.completed < 100) {
        //ensure we trigger progress event with completed = 100 for all items
        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);
      }

      if (FILE_STATE_TO_EVENT_MAP[item.state]) {
        //trigger UPLOADER EVENT for item based on its state
        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);
      }

      if (getIsFinalized(item)) {
        (0, _batchHelpers.incrementBatchFinishedCounter)(queue, item.batchId); //trigger FINALIZE event

        queue.trigger(_consts.UPLOADER_EVENTS.ITEM_FINALIZE, item);
      }
    }

    const index = state.itemQueue.indexOf(id);

    if (~index) {
      queue.updateState(state => {
        state.itemQueue.splice(index, 1);
        const activeIndex = state.activeIds.indexOf(id);

        if (~activeIndex) {
          state.activeIds.splice(activeIndex, 1);
        }
      });
    }
  }); //ensure finished batches are remove from state

  (0, _batchHelpers.cleanUpFinishedBatches)(queue);
  return next(queue);
};

var _default = processFinishedRequest;
exports.default = _default;
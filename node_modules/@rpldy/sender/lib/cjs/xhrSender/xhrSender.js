"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SUCCESS_CODES = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _MissingUrlError = _interopRequireDefault(require("../MissingUrlError"));

var _prepareFormData = _interopRequireDefault(require("./prepareFormData"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SUCCESS_CODES = [200, 201, 202, 203, 204];
exports.SUCCESS_CODES = SUCCESS_CODES;

const getRequestData = (items, options) => {
  let data;

  if (options.sendWithFormData) {
    _shared.logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);

    data = (0, _prepareFormData.default)(items, options);
  } else {
    if (items.length > 1) {
      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);
    }

    const item = items[0];

    _shared.logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);

    data = item.file || item.url;
  }

  return data;
};

const makeRequest = (items, url, options, onProgress, config) => {
  let xhr;
  const data = config !== null && config !== void 0 && config.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);

  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {
    requestOptions = (0, _shared.merge)({ ...(0, _shared.pick)(options, ["method", "headers", "withCredentials"]),
      preSend: req => {
        req.upload.onprogress = e => {
          if (e.lengthComputable && onProgress) {
            onProgress(e, items.slice());
          }
        };
      }
    }, requestOptions);
    const realPXhr = (0, _shared.request)(requestUrl, requestData, requestOptions); // $FlowFixMe -

    xhr = realPXhr.xhr;
    return realPXhr;
  }; //pXhr is a promise that resolves to the upload XHR


  const pXhr = config !== null && config !== void 0 && config.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();
  return {
    url,
    count: items.length,
    pXhr,
    getXhr: () => xhr,
    aborted: false
  };
};

const parseResponseJson = (response, headers, options) => {
  let parsed = response;
  const ct = headers === null || headers === void 0 ? void 0 : headers["content-type"];

  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes("json")) {
    try {
      parsed = JSON.parse(response);
    } catch {//silent fail
    }
  }

  return parsed;
};

const processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {
  var _options$formatServer, _options$formatServer2;

  let state, response, status;

  _shared.logger.debugLog("uploady.sender: received upload response ", xhr);

  state = ~SUCCESS_CODES.indexOf(xhr.status) ? _shared.FILE_STATES.FINISHED : _shared.FILE_STATES.ERROR;
  status = xhr.status;
  const resHeaders = (0, _shared.parseResponseHeaders)(xhr);
  response = {
    data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),
    headers: resHeaders
  };
  return {
    status,
    state,
    response
  };
}).catch(error => {
  let state, response;

  if (sendRequest.aborted) {
    state = _shared.FILE_STATES.ABORTED;
    response = "aborted";
  } else {
    _shared.logger.debugLog("uploady.sender: upload failed: ", error);

    state = _shared.FILE_STATES.ERROR;
    response = error;
  }

  return {
    error: true,
    state,
    response,
    status: 0
  };
});

const abortRequest = sendRequest => {
  let abortCalled = false;
  const {
    aborted,
    getXhr
  } = sendRequest;
  const xhr = getXhr();

  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {
    _shared.logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);

    xhr.abort();
    sendRequest.aborted = true;
    abortCalled = true;
  }

  return abortCalled;
};

const getXhrSend = config => (items, url, options, onProgress) => {
  if (!url) {
    throw new _MissingUrlError.default(_consts.XHR_SENDER_TYPE);
  }

  _shared.logger.debugLog("uploady.sender: sending file: ", {
    items,
    url,
    options
  });

  const sendRequest = makeRequest(items, url, options, onProgress, config);
  return {
    request: processResponse(sendRequest, options),
    abort: () => abortRequest(sendRequest),
    senderType: _consts.XHR_SENDER_TYPE
  };
};

var _default = getXhrSend;
exports.default = _default;